// Code generated by protoc-gen-go-grpc. DO NOT EDIT.
// versions:
// - protoc-gen-go-grpc v1.3.0
// - protoc             v3.21.12
// source: executor/executor.proto

package executor

import (
	context "context"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.32.0 or later.
const _ = grpc.SupportPackageIsVersion7

const (
	ExecutorRegistrar_Register_FullMethodName   = "/api.executor.ExecutorRegistrar/Register"
	ExecutorRegistrar_Deregister_FullMethodName = "/api.executor.ExecutorRegistrar/Deregister"
)

// ExecutorRegistrarClient is the client API for ExecutorRegistrar service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type ExecutorRegistrarClient interface {
	// Register the registration.
	Register(ctx context.Context, in *ExecutorRegisterRequest, opts ...grpc.CallOption) (*ExecutorRegisterReply, error)
	// Deregister the registration.
	Deregister(ctx context.Context, in *ExecutorDeregisterRequest, opts ...grpc.CallOption) (*ExecutorDeregisterReply, error)
}

type executorRegistrarClient struct {
	cc grpc.ClientConnInterface
}

func NewExecutorRegistrarClient(cc grpc.ClientConnInterface) ExecutorRegistrarClient {
	return &executorRegistrarClient{cc}
}

func (c *executorRegistrarClient) Register(ctx context.Context, in *ExecutorRegisterRequest, opts ...grpc.CallOption) (*ExecutorRegisterReply, error) {
	out := new(ExecutorRegisterReply)
	err := c.cc.Invoke(ctx, ExecutorRegistrar_Register_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *executorRegistrarClient) Deregister(ctx context.Context, in *ExecutorDeregisterRequest, opts ...grpc.CallOption) (*ExecutorDeregisterReply, error) {
	out := new(ExecutorDeregisterReply)
	err := c.cc.Invoke(ctx, ExecutorRegistrar_Deregister_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// ExecutorRegistrarServer is the server API for ExecutorRegistrar service.
// All implementations must embed UnimplementedExecutorRegistrarServer
// for forward compatibility
type ExecutorRegistrarServer interface {
	// Register the registration.
	Register(context.Context, *ExecutorRegisterRequest) (*ExecutorRegisterReply, error)
	// Deregister the registration.
	Deregister(context.Context, *ExecutorDeregisterRequest) (*ExecutorDeregisterReply, error)
	mustEmbedUnimplementedExecutorRegistrarServer()
}

// UnimplementedExecutorRegistrarServer must be embedded to have forward compatible implementations.
type UnimplementedExecutorRegistrarServer struct {
}

func (UnimplementedExecutorRegistrarServer) Register(context.Context, *ExecutorRegisterRequest) (*ExecutorRegisterReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Register not implemented")
}
func (UnimplementedExecutorRegistrarServer) Deregister(context.Context, *ExecutorDeregisterRequest) (*ExecutorDeregisterReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Deregister not implemented")
}
func (UnimplementedExecutorRegistrarServer) mustEmbedUnimplementedExecutorRegistrarServer() {}

// UnsafeExecutorRegistrarServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to ExecutorRegistrarServer will
// result in compilation errors.
type UnsafeExecutorRegistrarServer interface {
	mustEmbedUnimplementedExecutorRegistrarServer()
}

func RegisterExecutorRegistrarServer(s grpc.ServiceRegistrar, srv ExecutorRegistrarServer) {
	s.RegisterService(&ExecutorRegistrar_ServiceDesc, srv)
}

func _ExecutorRegistrar_Register_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ExecutorRegisterRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ExecutorRegistrarServer).Register(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ExecutorRegistrar_Register_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ExecutorRegistrarServer).Register(ctx, req.(*ExecutorRegisterRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ExecutorRegistrar_Deregister_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ExecutorDeregisterRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ExecutorRegistrarServer).Deregister(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ExecutorRegistrar_Deregister_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ExecutorRegistrarServer).Deregister(ctx, req.(*ExecutorDeregisterRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// ExecutorRegistrar_ServiceDesc is the grpc.ServiceDesc for ExecutorRegistrar service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var ExecutorRegistrar_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "api.executor.ExecutorRegistrar",
	HandlerType: (*ExecutorRegistrarServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Register",
			Handler:    _ExecutorRegistrar_Register_Handler,
		},
		{
			MethodName: "Deregister",
			Handler:    _ExecutorRegistrar_Deregister_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "executor/executor.proto",
}

const (
	Executor_Run_FullMethodName        = "/api.executor.Executor/Run"
	Executor_Kill_FullMethodName       = "/api.executor.Executor/Kill"
	Executor_GetUnitLog_FullMethodName = "/api.executor.Executor/GetUnitLog"
	Executor_Beat_FullMethodName       = "/api.executor.Executor/Beat"
	Executor_IdleBeat_FullMethodName   = "/api.executor.Executor/IdleBeat"
)

// ExecutorClient is the client API for Executor service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type ExecutorClient interface {
	// Run 触发任务单元
	Run(ctx context.Context, in *RunRequest, opts ...grpc.CallOption) (*RunReply, error)
	// Kill 杀死任务单元
	Kill(ctx context.Context, in *KillRequest, opts ...grpc.CallOption) (*KillReply, error)
	// GetUnitLog 获取任务日志
	GetUnitLog(ctx context.Context, in *UnitLogRequest, opts ...grpc.CallOption) (*UnitLogReply, error)
	// Beat 心跳检测
	Beat(ctx context.Context, in *BeatRequest, opts ...grpc.CallOption) (*BeatReply, error)
	// IdleBeat 忙碌检测
	IdleBeat(ctx context.Context, in *IdleBeatRequest, opts ...grpc.CallOption) (*IdleBeatReply, error)
}

type executorClient struct {
	cc grpc.ClientConnInterface
}

func NewExecutorClient(cc grpc.ClientConnInterface) ExecutorClient {
	return &executorClient{cc}
}

func (c *executorClient) Run(ctx context.Context, in *RunRequest, opts ...grpc.CallOption) (*RunReply, error) {
	out := new(RunReply)
	err := c.cc.Invoke(ctx, Executor_Run_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *executorClient) Kill(ctx context.Context, in *KillRequest, opts ...grpc.CallOption) (*KillReply, error) {
	out := new(KillReply)
	err := c.cc.Invoke(ctx, Executor_Kill_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *executorClient) GetUnitLog(ctx context.Context, in *UnitLogRequest, opts ...grpc.CallOption) (*UnitLogReply, error) {
	out := new(UnitLogReply)
	err := c.cc.Invoke(ctx, Executor_GetUnitLog_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *executorClient) Beat(ctx context.Context, in *BeatRequest, opts ...grpc.CallOption) (*BeatReply, error) {
	out := new(BeatReply)
	err := c.cc.Invoke(ctx, Executor_Beat_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *executorClient) IdleBeat(ctx context.Context, in *IdleBeatRequest, opts ...grpc.CallOption) (*IdleBeatReply, error) {
	out := new(IdleBeatReply)
	err := c.cc.Invoke(ctx, Executor_IdleBeat_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// ExecutorServer is the server API for Executor service.
// All implementations must embed UnimplementedExecutorServer
// for forward compatibility
type ExecutorServer interface {
	// Run 触发任务单元
	Run(context.Context, *RunRequest) (*RunReply, error)
	// Kill 杀死任务单元
	Kill(context.Context, *KillRequest) (*KillReply, error)
	// GetUnitLog 获取任务日志
	GetUnitLog(context.Context, *UnitLogRequest) (*UnitLogReply, error)
	// Beat 心跳检测
	Beat(context.Context, *BeatRequest) (*BeatReply, error)
	// IdleBeat 忙碌检测
	IdleBeat(context.Context, *IdleBeatRequest) (*IdleBeatReply, error)
	mustEmbedUnimplementedExecutorServer()
}

// UnimplementedExecutorServer must be embedded to have forward compatible implementations.
type UnimplementedExecutorServer struct {
}

func (UnimplementedExecutorServer) Run(context.Context, *RunRequest) (*RunReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Run not implemented")
}
func (UnimplementedExecutorServer) Kill(context.Context, *KillRequest) (*KillReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Kill not implemented")
}
func (UnimplementedExecutorServer) GetUnitLog(context.Context, *UnitLogRequest) (*UnitLogReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetUnitLog not implemented")
}
func (UnimplementedExecutorServer) Beat(context.Context, *BeatRequest) (*BeatReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Beat not implemented")
}
func (UnimplementedExecutorServer) IdleBeat(context.Context, *IdleBeatRequest) (*IdleBeatReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method IdleBeat not implemented")
}
func (UnimplementedExecutorServer) mustEmbedUnimplementedExecutorServer() {}

// UnsafeExecutorServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to ExecutorServer will
// result in compilation errors.
type UnsafeExecutorServer interface {
	mustEmbedUnimplementedExecutorServer()
}

func RegisterExecutorServer(s grpc.ServiceRegistrar, srv ExecutorServer) {
	s.RegisterService(&Executor_ServiceDesc, srv)
}

func _Executor_Run_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RunRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ExecutorServer).Run(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Executor_Run_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ExecutorServer).Run(ctx, req.(*RunRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Executor_Kill_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(KillRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ExecutorServer).Kill(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Executor_Kill_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ExecutorServer).Kill(ctx, req.(*KillRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Executor_GetUnitLog_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UnitLogRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ExecutorServer).GetUnitLog(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Executor_GetUnitLog_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ExecutorServer).GetUnitLog(ctx, req.(*UnitLogRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Executor_Beat_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(BeatRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ExecutorServer).Beat(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Executor_Beat_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ExecutorServer).Beat(ctx, req.(*BeatRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Executor_IdleBeat_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(IdleBeatRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ExecutorServer).IdleBeat(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Executor_IdleBeat_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ExecutorServer).IdleBeat(ctx, req.(*IdleBeatRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// Executor_ServiceDesc is the grpc.ServiceDesc for Executor service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var Executor_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "api.executor.Executor",
	HandlerType: (*ExecutorServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Run",
			Handler:    _Executor_Run_Handler,
		},
		{
			MethodName: "Kill",
			Handler:    _Executor_Kill_Handler,
		},
		{
			MethodName: "GetUnitLog",
			Handler:    _Executor_GetUnitLog_Handler,
		},
		{
			MethodName: "Beat",
			Handler:    _Executor_Beat_Handler,
		},
		{
			MethodName: "IdleBeat",
			Handler:    _Executor_IdleBeat_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "executor/executor.proto",
}
